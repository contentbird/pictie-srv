// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, faye, fs, http, memory_users, path, redis, redis_users, sanitize, url, _config, _tools,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  http = require('http');

  fs = require('fs');

  url = require('url');

  path = require('path');

  faye = require('faye');

  redis = require('faye-redis');

  memory_users = require('./memory_users_manager');

  redis_users = require('./redis_users_manager');

  sanitize = require('validator').sanitize;

  _tools = require('../lib/tools.js');

  _config = require('../lib/config.js');

  EventEmitter = require('events').EventEmitter;

  this.Server = (function(_super) {

    __extends(Server, _super);

    function Server() {}

    Server.prototype.startHTTP = function(http_port, callback) {
      var port, requestHandler;
      port = _config.port(http_port);
      requestHandler = function(request, response) {
        var body, uri;
        uri = url.parse(request.url).pathname;
        if (uri === '/') {
          response.writeHead(200, {
            'Content-Type': 'text/html'
          });
          response.write('Pictie socket server is on /bayeux ; faye client is on bayeux/client.js');
          return response.end();
        } else if (uri === '/messages') {
          if (request.method === 'POST') {
            console.log("POST " + uri);
            body = '';
            request.on('data', function(data) {
              body += data;
              if (body.length > 1e6) {
                return request.connection.destroy();
              }
            });
            return request.on('end', function() {
              var json, post;
              post = JSON.parse(body);
              json = JSON.stringify({
                message: {
                  sender: post.sender,
                  recipient: post.recipient,
                  body: post.body
                }
              });
              response.writeHead(200, {
                'Content-Type': 'application/json',
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "X-Requested-With, Content-Type"
              });
              return response.end(json);
            });
          } else {
            response.writeHead(200, {
              'Content-Type': 'application/json',
              "Access-Control-Allow-Origin": "*",
              "Access-Control-Allow-Headers": "X-Requested-With, Content-Type"
            });
            return response.end();
          }
        }
      };
      this.httpServer = http.createServer(requestHandler);
      return this.httpServer.listen(Number(port), function() {
        return callback();
      });
    };

    Server.prototype.attachFaye = function(engine, db) {
      var redis_url, _ref;
      if (db == null) {
        db = null;
      }
      if (engine === 'redis') {
        this.engine = 'redis';
        redis_url = _config.redis_url();
        this.bayeux = new faye.NodeAdapter({
          mount: '/bayeux',
          timeout: 20,
          engine: {
            type: redis,
            host: redis_url.hostname,
            port: parseInt(redis_url.port),
            password: (_ref = redis_url.auth) != null ? _ref.split(':').slice(-1)[0] : void 0
          }
        });
        this.users_manager = new redis_users.RedisUsersManager(db);
      } else {
        this.engine = 'memory';
        this.bayeux = new faye.NodeAdapter({
          mount: '/bayeux',
          timeout: 20
        });
        this.users_manager = new memory_users.MemoryUsersManager;
      }
      return this.bayeux.attach(this.httpServer);
    };

    Server.prototype.sanitizeIncomingMessages = function() {
      return this.bayeux.addExtension({
        incoming: function(message, callback) {
          if (/chat/.test(message.channel) && (message.data.message != null)) {
            message.data.message = sanitize(message.data.message).entityEncode();
          }
          return callback(message);
        }
      });
    };

    Server.prototype.authenticateOnMetaSubscriptions = function() {
      return this.bayeux.addExtension({
        incoming: function(message, callback) {
          if (message.channel === '/meta/subscribe') {
            if (!((message.ext != null) && (message.ext.authToken != null) && (message.ext.group != null))) {
              message.error = 'Cannot validate auth token';
              return callback(message);
            }
            if (_tools.encrypt_token("sparta/chat/" + message.ext.group) !== message.ext.authToken) {
              message.error = 'Invalid subscription auth token';
            }
          }
          return callback(message);
        }
      });
    };

    Server.prototype.maintainUserList = function() {
      var _this = this;
      this.bayeux.addExtension({
        incoming: function(message, callback) {
          if (message.channel === '/meta/subscribe') {
            return _this.users_manager.subscribeUser(message, callback);
          } else {
            return callback(message);
          }
        }
      });
      this.bayeux.bind('subscribe', function(clientId, channel) {
        if (/chat/.test(channel)) {
          _this.users_manager.addUserToChannel(clientId, channel, function() {
            return _this.publish_new_user_list(channel, 'join', clientId);
          });
        }
        if (/presence/.test(channel)) {
          _this.users_manager.getConnectedFriends(clientId, function(connected_friends) {
            _this.publish_connected_friends_list(channel, connected_friends, function() {
              if (_config.env.dev) {
                return _this.emit('friendsListPublished');
              }
            });
            return _this.publish_new_user_to_his_friends(clientId, connected_friends, function() {
              if (_config.env.dev) {
                return _this.emit('friendsNotified');
              }
            });
          });
        }
        if (/chat\/1to1___/.test(channel)) {
          return _this.invite_other_user_to_1to1_chat(clientId, channel);
        }
      });
      this.bayeux.bind('unsubscribe', function(clientId, channel) {
        if (/chat/.test(channel)) {
          return _this.users_manager.removeUserFromChannel(clientId, channel, function() {
            return _this.publish_new_user_list(channel, 'leave', clientId);
          });
        }
      });
      return this.bayeux.bind('disconnect', function(clientId) {
        return _this.users_manager.unsubscribeUser(clientId, function(disconnectedUsername, friendsToNotify) {
          var friend, _i, _len, _results;
          if (disconnectedUsername && friendsToNotify.length > 0) {
            _results = [];
            for (_i = 0, _len = friendsToNotify.length; _i < _len; _i++) {
              friend = friendsToNotify[_i];
              _results.push(_this.bayeux.getClient().publish("/presence/" + friend, {
                evt: 'friend_leaved',
                friend_name: disconnectedUsername
              }));
            }
            return _results;
          }
        });
      });
    };

    Server.prototype.stop = function() {
      return this.httpServer.close();
    };

    Server.prototype.publish_new_user_list = function(channel, movement, clientId) {
      var _this = this;
      return this.users_manager.usersInChannel(channel, function(users) {
        return _this.bayeux.getClient().publish(channel, {
          evt: movement,
          clientId: clientId,
          user_list: users
        });
      });
    };

    Server.prototype.publish_connected_friends_list = function(channel, friends, callback) {
      this.bayeux.getClient().publish(channel, {
        evt: 'connected_friends',
        friends_list: friends
      });
      return callback();
    };

    Server.prototype.publish_new_user_to_his_friends = function(clientId, friends, callback) {
      var _this = this;
      return this.users_manager.getUserInfo(clientId, function(userInfo) {
        var friend, _i, _len;
        for (_i = 0, _len = friends.length; _i < _len; _i++) {
          friend = friends[_i];
          _this.bayeux.getClient().publish("/presence/" + friend, {
            evt: 'friend_joined',
            friend_name: userInfo.user_name
          });
        }
        return callback();
      });
    };

    Server.prototype.invite_other_user_to_1to1_chat = function(clientId, channel) {
      var _this = this;
      return this.users_manager.getUserInfo(clientId, function(userInfo) {
        var friendName, myName;
        myName = userInfo.user_name;
        friendName = channel.split('___').slice(-2).filter(function(name) {
          return name !== myName;
        });
        return _this.bayeux.getClient().publish("/presence/" + friendName, {
          evt: '1to1_chat_invite',
          invitor_name: myName
        });
      });
    };

    return Server;

  })(EventEmitter);

}).call(this);
